#' @title DomeSelectivityEstimator Class
#'
#' @description
#' Class that estimate some shape selectivity for a list of gears using SELECT
UtpbDomeSELECTEstimator <- R6::R6Class("UtpbDomeSELECTEstimator", public = list( # nolint
  # @formatter:off
  #' @field length_fq long dataframe with lengths and gears
  length_fq = NULL,
  #' @field fishing_power named list with the relative fishing power of each gear
  fishing_power = NULL,
  #' @field mesh_sizes named list with every mesh size sorted by asceding order
  mesh_sizes = NULL,
  #' @field catch_context R6 object with the context of the catch dataframe
  catch_context = NULL,
  #' @field models vector of model names to be estimated by SELECT
  models = NULL,
  #' @description
  #' Initialise class DomeSelectivityEstimator
  #' @param length_fq long dataframe with lengths and gears
  #' @param fishing_power named list with the relative fishing power of each gear
  #' @param mesh_sizes named list with every mesh size
  #' @param catch_context catch_context R6 object with the context of the catch dataframe
  #' @param models to be estimated as part of the selectivity indirect methods
  #' @param length_fq long dataframe with lengths and gears
  # @formatter:on
  initialize = function(length_fq, fishing_power, mesh_sizes, catch_context, models) {
    self$length_fq <- length_fq
    self$fishing_power <- fishing_power
    self$mesh_sizes <- mesh_sizes
    self$catch_context <- catch_context
    self$models <- models
  },
  # @formatter:off
  #' @description
  #' Build a long non-aggregated dataframe with catches associated to length classes and year
  #'
  #' @returns a named list of dataframes with the length classes and catches, one per year
  #' @export
  # @formatter:on
  build_gear_yearly_length_class_catch = function(min_padding = 0, up_to_linf = TRUE) {
    return(
      lapply(names(self$mesh_sizes), function(gear_name) {
        gear_catch_data <- self$length_fq %>%
          dplyr::filter(arte_grupo == gear_name)
        utpb_data_compositor <- utpbwlfq::UtpbDataComposition$new(gear_catch_data, self$catch_context)
        result <- utpb_data_compositor$build_catch_at_length(self$catch_context$bindwidth,
                                                             self$catch_context$col_prefix,
                                                             min_padding,
                                                             up_to_linf = up_to_linf)
        return(result$catch_long_t)
      })
    )
  },
  # @formatter:off
  #' @description
  #' Build a long non-aggregated dataframe with catches associated to length classes and year
  #'
  #' @gear_data a named list with long dataframes representing yearly length-class catches
  #' @returns a named list of dataframes with the length classes and catches, one per year
  #' @export
  # @formatter:on
  build_select_catch_matrix = function(gear_data) {
    gears_total_catch <- list()
    new_total_columns <- list()
    for (gear_name in names(gear_data)) {
      total_catch_column <- paste0("total_catch_", gear_name)
      gears_total_catch[[gear_name]] <- gear_data[[gear_name]] %>%
        dplyr::group_by(MeanLength) %>%
        dplyr::summarise_at(.vars = total_catch_column, sum, catch)
      new_total_columns[[total_catch_column]] <- 0
    }
    gears_total_catch %>%
      purrr::reduce(merge, by = "MeanLength", all = TRUE) %>%
      tidyr::replace_na(new_total_columns)

  },
  estimate_selectivity_by_models = function() {

  }
), private = list(
  df_to_unname_matrix = function(data, from_col = NULL, to_col = NULL) {
    from_col <- ifelse(is.null(from_col), 1, from_col)
    to_col <- ifelse(is.null(to_col), length(names(data)), to_col)
    return(
      unname(as.matrix(data[, from_col:to_col]))
    )
  }
))
